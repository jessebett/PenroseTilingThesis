(* ::Package:: *)

BeginPackage["PenroseTilingFunctions`"];


\[Phi]::usage="Gives Golden Ratio to Numerical Precision";
\[Phi]=GoldenRatio;

\[CapitalPsi]::usage="Gives -\!\(\*SuperscriptBox[\(\[Phi]\), \(-1\)]\), Inverse of Golden Ratio, to Numerical Precision";
\[CapitalPsi]=1-\[Phi]//N;

\[Theta]::usage="Gives rotation by \!\(\*FractionBox[\(2  \[Pi]\), \(5\)]\) as complex number, to Numerical Precision";
\[Theta]=Exp[I*Pi*2/5]//N;


Fat::usage = "Formats list for fat triangle from list of verticies";
Skinny::usage="Formats list for skinny triangles from list of verticies";
IfFat::usage="T if the triangle is fat, F if skinny";
Coor::usage="Gives Cartesian coordinates from list of complex numbers";
Cent::usage="Gives coordinate of center of Rhombus generated by input triangle";
Conj::usage="Conjugates complex coordinates";
AddConj::usage="Takes a given list of polygons and includes their conjugations.";
Cull::usage="Removes triangles which generate the same rhombus";
Rhomb::usage="Produces verticies for a rhombus from a given triangle";
\[CapitalDelta]::usage="Extracts vertex information from a given polynomial";
See::usage="Displays list of polygons as a graphic";

Fat[{a_,b_,c_}]:={{a,b,c},"fat"};
Skinny[{a_,b_,c_}]:={{a,b,c},"skinny"};
IfFat[t_, T_, F_] := If[Last[t] == "fat", T, F];
Coor:=Transpose[{Re/@#,Im/@#}]&;
Cent[{{a_,b_,c_},f_}]:=(a+b)*0.5;
Conj[{{a_,b_,c_},f_}]:={Conjugate/@{a,b,c},f};
AddConj[list_]:=Union[list,Conj/@list];
Cull[l_]:=DeleteDuplicatesBy[l,Cent];
Rhomb[{{a_,b_,c_},f_}]:={{a,a-c+b,b,c},f};
RhombTri[{{a_,b_,c_},f_}]:={{a,b,a-c+b},f};
AddRhombTris[list_]:=Union[list,RhombTri/@list];
\[CapitalDelta][{t_,fs_}]:=t;
See:=Graphics[{Transpose[{Map[IfFat[#,NicePurple,NiceYellow]&,#]&@#,Polygon/@Coor/@\[CapitalDelta]/@#}]}]&
SeeEdges:=Graphics[{EdgeForm[Black],Opacity[0.8],{Transpose[{((IfFat[#1,White,White]&)/@#1&)[#1],Polygon/@Coor/@\[CapitalDelta]/@#1}]}}]&


 


FatInflate::usage="Inflation Rules for fat triangles";
SkinnyInflate::usage="Inflation Rules for skinny triangles";
InflationRules::usage="Inflation Rules for triangles";
Inflate::usage="Applies the Inflation Rules n times on a seed of triangles";
FullInflate::usage="Inflates, Conjugates, Culls, and Converts to Rhombs";

FatInflate[{{a_, b_, c_}, f_}] :=
 Block[{
   d = a + (c - a)/\[Phi],
   e = a + (b - a)/\[Phi]},
  {Fat[{e, a, d}], Skinny[{d, c, e}], Fat[{b, c, e}]}]

SkinnyInflate[{{a_, b_, c_}, s_}] :=
 Block[{d = c + (a - c)/\[Phi]},
  {Skinny[{d, a, b}], Fat[{b, c, d}]}]

InflationRules := If[Last[#] == "fat", FatInflate[#], SkinnyInflate[#]] &
Inflate[seed_,n_]:=Nest[Flatten[InflationRules /@ #, 1] &, seed, n];

FullInflate[seed_,n_]:= Rhomb/@Cull@AddConj@Inflate[seed, n];


unitfat::usage="Fat Robinson triangle centered at origin";
unitskinny::usage="Skinny Robinson triangle centered at origin";

unitfat = Fat[{-\[Phi]/2, \[Phi]/2, E^((4 I \[Pi])/5) + \[Phi]/2}];
unitskinny = Skinny[{-0.5, 0.5, 0.5 Sqrt[5 + 2 Sqrt[5]] I}];


starseed::usage="Arrangment of fat Robinson triangles which inflate to a star";

starseed=Module[
{x0 = 1},{x1 = x0*\[Theta]; 
x2 = x1*\[Theta]; 
y2 = -\[Phi]; 
y1 = y2/\[Theta]; 
y0 = y1/\[Theta];
Fat[{0, y0, x0}], Fat[{0, y0, x1}], Fat[{0, y1, x1}], 
   Fat[{0, y1, x2}], Fat[{0, y2, x2}]}];


Navy = RGBColor[
 0., 0.12156862745098039`, 0.24705882352941178`]; 
NiceBlue = RGBColor[
 0., 0.4549019607843137, 0.8509803921568627]; 
Teal = RGBColor[
 0.22352941176470587`, 0.8, 0.8]; 
Olive = RGBColor[
 0.2392156862745098, 0.6, 0.4392156862745098]; 
NiceGreen = RGBColor[
 0.1803921568627451, 0.8, 0.25098039215686274`]; 
Lime = RGBColor[
 0.00392156862745098, 1., 0.4392156862745098];
NiceYellow = RGBColor[1., 0.8627450980392157, 0.];
NiceOrange = RGBColor[1., 0.5215686274509804, 0.10588235294117647`];
NiceRed = RGBColor[1., 0.2549019607843137, 0.21176470588235294`];
NicePurple = RGBColor[
  0.6941176470588235, 0.050980392156862744`, 0.788235294117647];


KitesEdges[{{A_, B_, C_}, t_}] := If[t == "fat", Line[Coor[{A, B}]], Line[Coor[{B, C}]]]
KiteBreak[{{A_,B_,C_},t_}]:=If[t=="fat",{{{A,C,A+(A-B)(1-\[Phi])},"kite"},{{B,C,A+(A-B)(1-\[Phi])},"dart"}},{{{A,B,C},"kite"}}]
KiteFill:=If[Last@#=="kite",{NiceOrange,Triangle@Coor@First@#},{NiceBlue,Triangle@Coor@First@#}]&
SeeKitesDatrts[list_]:= Graphics[Triangle/@Coor/@Flatten[KiteFill/@list,1]]


SeeTri[points_]:=Graphics@Polygon@Coor@points

Midpoints[{A_,B_,C_}]:=1/2{B+A,B+C,A+C}

Orientation[{A_,B_,C_}]:=Sign@Det[{Flatten@Coor@{B-A},Flatten@Coor@{((C-B))}}]

OrientTriangle[{A_,B_,C_}]:=If[Orientation[{A,B,C}]==1,{A,B,C},{A,C,B}]

PathTriangles[{{A_,P_,B_,C_},t_}]:=If[t=="fat",{{A,P,C},{B,C,P}},{{A,B,C},{A,P,B}}]

MakePathTriangles[list_]:=OrientTriangle/@Flatten[PathTriangles/@list,1]

EqualQ[list_,element_]:=Equal[#,element]&/@list

SharedSide[list_,element_]:=Select[list,MemberQ[n_/;Abs[n-element]<10^-10]]

FindNextTriangle[list_,prev_,midpoint_]:=DeleteCases[SharedSide[list,midpoint],prev]

ChangeTriangle[list_,prev_,midpoint_]:=Flatten@FindNextTriangle[list,prev,midpoint]

Go[{starttriangle_,startside_},dir_]:=Part[starttriangle,Mod[startside+dir,3,1]]

PathStep[list_,{starttriangle_,startmidpoint_,dir_}]:=
Module[{nexttriangle,nextmidpoint,startside=First@Flatten@Position[starttriangle,n_/;Abs[n-startmidpoint]<10^-10],nextdir=-1*dir},nextmidpoint=Go[{starttriangle,startside},dir];
{ChangeTriangle[list,starttriangle,nextmidpoint],nextmidpoint,nextdir}]

MakePath[list_,{starttriangle_,startmidpoint_,dir_}]:=DeleteCases[NestWhileList[PathStep[list,#]&,{starttriangle,startmidpoint,dir},UnsameQ,All],{{},{}[[_]],_}]

PathPoints[list_]:=Line/@Partition[Coor@list[[All,2]],2,1]

GeneratePath[{tiling_,starttri_,startside_,direction_}]:=PathPoints@MakePath[tiling,{tiling[[starttri]],tiling[[starttri,startside]],direction}]


CCW[{\[Theta]_,\[Alpha]_}]:=If[\[Theta]<\[Alpha],{\[Theta],\[Alpha]},{\[Theta],\[Alpha]+2Pi}]

CW[{\[Theta]_,\[Alpha]_}]:=If[\[Theta]<\[Alpha],{\[Alpha],\[Theta]+2Pi},{\[Alpha],\[Theta]}]

MakeCurveRules[{{A_,B_,C_},t_}]:=Module[
{coors=Coor@{A,B,C},
littlelength=If[t=="fat",Abs[C-A],Abs[B-C]],
biglength=If[t=="fat",Abs[B-A],Abs[C-A]],
A\[Theta]1=Arg[B-A],
A\[Theta]2=Arg[C-A],
B\[Theta]1=Arg[A-B],
B\[Theta]2=Arg[C-B]},
littleradius=littlelength/(1+\[Phi]);
bigradius=littlelength-littleradius;

coorA=coors[[1]];
coorB=coors[[2]];
coorC=coors[[3]];
orientation=Sign@Det[Transpose@{(coorA-coorB),(coorC-coorB)}];

{A\[Theta]1,A\[Theta]2}=If[orientation==1,
CW[#],
CCW[#]]&@{A\[Theta]1,A\[Theta]2};

{B\[Theta]1,B\[Theta]2}=If[orientation==1,
CCW[#],
CW[#]]&@{B\[Theta]1,B\[Theta]2};

Color1=NiceOrange;
Color2=NiceBlue;

If[t=="fat",
{{Thick,Color1,Circle[coorA,bigradius,{A\[Theta]1,A\[Theta]2}]},{Thick,Color2,Circle[coorB,littleradius,{B\[Theta]1,B\[Theta]2}]}},
{{Thick, Color1,Circle[coorA,littleradius,{A\[Theta]1,A\[Theta]2}]},{Thick,Color2,Circle[coorB,littleradius,{B\[Theta]1,B\[Theta]2}]}}]]


EndPackage[]
